#### Define relationships between objects
Because SQLite is a relational database, you can specify relationships between entities. 
Even though most object-relational mapping libraries allow entity objects to reference 
each other, Room explicitly forbids this. To learn about the technical reasoning behind
this decision, see Understand why Room doesn't allow object references.

Create embedded objects
Sometimes, you'd like to express an entity or data object as a cohesive whole in your database 
logic, even if the object contains several fields. In these situations, you can use the @Embedded
annotation to represent an object that you'd like to decompose into its subfields within a table.
You can then query the embedded fields just as you would for other individual columns.

For instance, your User class can include a field of type Address, which represents a composition
of fields named street, city, state, and postCode. To store the composed columns separately in the table,
include an Address field in the User class that is annotated with @Embedded, as shown in the following code snippet:

JAVA
public class Address {
    public String street;
    public String state;
    public String city;

    @ColumnInfo(name = "post_code") public int postCode;
}

@Entity
public class User {
    @PrimaryKey public int id;

    public String firstName;

    @Embedded public Address address;
}

#### Define one-to-one relationships
A one-to-one relationship between two entities is a relationship where each instance of
the parent entity corresponds to exactly one instance of the child entity, and vice-versa.

For example, consider a music streaming app where the user has a library of songs that they own. 
\Each user has only one library, and each library corresponds to exactly one user. Therefore,
there should be a one-to-one relationship between the User entity and the Library entity.

First, create a class for each of your two entities. One of the entities must include 
a variable that is a reference to the primary key of the other entity.

KOTLIN
JAVA
@Entity
public class User {
    @PrimaryKey public long userId;
    public String name;
    public int age;
}

@Entity
public class Library {
    @PrimaryKey public long libraryId;
    public long userOwnerId;
}

In order to query the list of users and corresponding libraries, you must first model the
one-to-one relationship between the two entities. To do this, create a new data class where
each instance holds an instance of the parent entity and the corresponding instance of the
child entity. Add the @Relation annotation to the instance of the child entity, with parentColumn
set to the name of the primary key column of the parent entity and entityColumn set to the name 
of the column of the child entity that references the parent entity's primary key.

KOTLIN
JAVA
public class UserAndLibrary {
    @Embedded public User user;
    @Relation(
         parentColumn = "userId",
         entityColumn = "userOwnerId"
    )
    public Library library;
}

Finally, add a method to the DAO class that returns all instances of the data class that pairs
the parent entity and the child entity. This method requires Room to run two queries, so add
the @Transaction annotation to this method to ensure that the whole operation is performed atomically.
