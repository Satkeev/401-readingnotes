###Inheritance

In the preceding lessons, you have seen inheritance mentioned several times. In the Java language, classes can be
derived from other classes, thereby inheriting fields and methods from those classes.
Definitions: A class that is derived from another class is called a subclass (also a derived class, extended class,
or child class). The class from which the subclass is derived is called a superclass (also a base class or a parent class).
Excepting Object, which has no superclass, every class has one and only one direct superclass (single inheritance).
In the absence of any other explicit superclass, every class is implicitly a subclass of Object.
Classes can be derived from classes that are derived from classes that are derived from classes, and so on, and ultimately
derived from the topmost class, Object. Such a class is said to be descended from all the classes in the inheritance
chain stretching back to Object.
The idea of inheritance is simple but powerful: When you want to create a new class and there is already a class that
includes some of the code that you want, you can derive your new class from the existing class. In doing this, you
can reuse the fields and methods of the existing class without having to write (and debug!) them yourself.
A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, 
so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.

###The Java Platform Class Hierarchy
The Object class, defined in the java.lang package, defines and implements behavior common to all classes—including
the ones that you write. In the Java platform, many classes derive directly from Object, other classes derive from some of
those classes, and so on, forming a hierarchy of classes.
All Classes in the Java Platform are Descendants of Object
All Classes in the Java Platform are Descendants of Object
At the top of the hierarchy, Object is the most general of all classes. Classes near the bottom of the hierarchy
provide more specialized behavior.
An Example of Inheritance
Here is the sample code for a possible implementation of a Bicycle class that was presented in the Classes and Objects lesson:

public class Bicycle {
        
    // the Bicycle class has three fields
    public int cadence;
    public int gear;
    public int speed;
      
    // the Bicycle class has one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // the Bicycle class has four methods
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
A class declaration for a MountainBike class that is a subclass of Bicycle might look like this:

public class MountainBike extends Bicycle {
        
    // the MountainBike subclass adds one field
    public int seatHeight;

    // the MountainBike subclass has one constructor
    public MountainBike(int startHeight,
                        int startCadence,
                        int startSpeed,
                        int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass adds one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   
}
MountainBike inherits all the fields and methods of Bicycle and adds the field seatHeight and a method to set it. Except for 
the constructor, it is as if you had written a new MountainBike class entirely from scratch, with four fields and five methods.
However, you didn't have to do all the work. This would be especially valuable if the methods in the Bicycle class were complex 
and had taken substantial time to debug.

What You Can Do in a Subclass
A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in. If the 
subclass is in the same package as its parent, it also inherits the package-private members of the parent. You can use the
inherited members as is, replace them, hide them, or supplement them with new members:


###Interfaces

There are a number of situations in software engineering when it is important for disparate groups of programmers to 
agree to a "contract" that spells out how their software interacts. Each group should be able to write their code
without any knowledge of how the other group's code is written. Generally speaking, interfaces are such contracts.
For example, imagine a futuristic society where computer-controlled robotic cars transport passengers through city 
streets without a human operator. Automobile manufacturers write software (Java, of course) that operates the 
automobile—stop, start, accelerate, turn left, and so forth. Another industrial group, electronic guidance
instrument manufacturers, make computer systems that receive GPS (Global Positioning System) position data and
wireless transmission of traffic conditions and use that information to drive the car.

The auto manufacturers must publish an industry-standard interface that spells out in detail what methods can be
invoked to make the car move (any car, from any manufacturer). The guidance manufacturers can then write software
that invokes the methods described in the interface to command the car. Neither industrial group needs to know how
the other group's software is implemented. In fact, each group considers its software highly proprietary and reserves 
the right to modify it at any time, as long as it continues to adhere to the published interface.

###Interfaces in Java
In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, 
method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods
and static methods. Interfaces cannot be instantiated—they can only be implemented by classes or extended by other
interfaces. Extension is discussed later in this lesson.

Defining an interface is similar to creating a new class:

public interface OperateCar {

   // constant declarations, if any

   // method signatures
   
   // An enum with values RIGHT, LEFT
   int turn(Direction direction,
            double radius,
            double startSpeed,
            double endSpeed);
   int changeLanes(Direction direction,
                   double startSpeed,
                   double endSpeed);
   int signalTurn(Direction direction,
                  boolean signalOn);
   int getRadarFront(double distanceToCar,
                     double speedOfCar);
   int getRadarRear(double distanceToCar,
                    double speedOfCar);
         ......
   // more method signatures
}
Note that the method signatures have no braces and are terminated with a semicolon.

To use an interface, you write a class that implements the interface. When an instantiable class implements an interface,
it provides a method body for each of the methods declared in the interface. For example,

public class OperateBMW760i implements OperateCar {

    // the OperateCar method signatures, with implementation --
    // for example:
    int signalTurn(Direction direction, boolean signalOn) {
       // code to turn BMW's LEFT turn indicator lights on
       // code to turn BMW's LEFT turn indicator lights off
       // code to turn BMW's RIGHT turn indicator lights on
       // code to turn BMW's RIGHT turn indicator lights off
    }

    // other members, as needed -- for example, helper classes not 
    // visible to clients of the interface
}
