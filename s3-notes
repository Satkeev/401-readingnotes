####Introduction to Amazon S3


Amazon S3 has a simple web services interface that you can use to store and retrieve any amount of data, 
at any time, from anywhere on the web.
This guide describes how you send requests to create buckets, store and retrieve your objects, and manage
permissions on your resources. The guide also describes access control and the authentication process.
Access control defines who can access objects and buckets within Amazon S3, and the type of access
(for example, READ and WRITE). The authentication process verifies the identity of a user who is trying to
access Amazon Web Services (AWS).
### Advantages of using Amazon S3
Amazon S3 is intentionally built with a minimal feature set that focuses on simplicity and robustness.
Following are some of the advantages of using Amazon S3:
Creating buckets – Create and name a bucket that stores data. Buckets are the fundamental containers in
Amazon S3 for data storage.
Storing data – Store an infinite amount of data in a bucket. Upload as many objects as you like into an
Amazon S3 bucket. Each object can contain up to 5 TB of data. Each object is stored and retrieved using 
a unique developer-assigned key.

Downloading data – Download your data or enable others to do so. Download your data anytime you like,
or allow others to do the same.
Permissions – Grant or deny access to others who want to upload or download data into your Amazon S3 bucket.
Grant upload and download permissions to three types of users. Authentication mechanisms can help keep data secure
from unauthorized access.
Standard interfaces – Use standards-based REST and SOAP interfaces designed to work with any internet-development toolkit.

Note
SOAP support over HTTP is deprecated, but it is still available over HTTPS. New Amazon S3 features will not be supported 
for SOAP. We recommend that you use either the REST API or the AWS SDKs.

Amazon S3 concepts
This section describes key concepts and terminology you need to understand to use Amazon S3 effectively. 
They are presented in the order that you will most likely encounter them.

### Amazon S3 data consistency model
Buckets
A bucket is a container for objects stored in Amazon S3. Every object is contained in a bucket. For example,
if the object named photos/puppy.jpg is stored in the awsexamplebucket1 bucket in the US West (Oregon) Region,
then it is addressable using the URL https://awsexamplebucket1.s3.us-west-2.amazonaws.com/photos/puppy.jpg.

Buckets serve several purposes:
They organize the Amazon S3 namespace at the highest level.
They identify the account responsible for storage and data transfer charges.
They play a role in access control.
They serve as the unit of aggregation for usage reporting.
You can configure buckets so that they are created in a specific AWS Region. For more information, see Accessing a
Bucket. You can also configure a bucket so that every time an object is added to it, Amazon S3 generates a unique
version ID and assigns it to the object. For more information, see Using Versioning.
For more information about buckets, see Working with Amazon S3 Buckets.

### Objects
Objects are the fundamental entities stored in Amazon S3. Objects consist of object data and metadata.
The data portion is opaque to Amazon S3. The metadata is a set of name-value pairs that describe the object. 
These include some default metadata, such as the date last modified, and standard HTTP metadata, such as 
Content-Type. You can also specify custom metadata at the time the object is stored.
An object is uniquely identified within a bucket by a key (name) and a version ID. For more information,
see Keys and Using Versioning.

Keys
A key is the unique identifier for an object within a bucket. Every object in a bucket has exactly one key. 
The combination of a bucket, key, and version ID uniquely identify each object. So you can think of Amazon
S3 as a basic data map between "bucket + key + version" and the object itself. Every object in Amazon S3 can be
uniquely addressed through the combination of the web service endpoint, bucket name, key, and optionally, 
a version. For example, in the URL https://doc.s3.amazonaws.com/2006-03-01/AmazonS3.wsdl, "doc" is the
name of the bucket and "2006-03-01/AmazonS3.wsdl" is the key.

For more information about object keys, see Object Keys.
##Regions
You can choose the geographical AWS Region where Amazon S3 will store the buckets that you create. You might choose 
a Region to optimize latency, minimize costs, or address regulatory requirements. Objects stored in a Region never 
leave the Region unless you explicitly transfer them to another Region. For example, objects stored in the Europe
(Ireland) Region never leave it.
Note
You can only access Amazon S3 and its features in AWS Regions that are enabled for your account.

For a list of Amazon S3 Regions and endpoints, see Regions and Endpoints in the AWS General Reference.

#### Amazon S3 data consistency model
Amazon S3 provides read-after-write consistency for PUTS of new objects in your S3 bucket in all Regions with one
caveat. The caveat is that if you make a HEAD or GET request to a key name before the object is created, then 
create the object shortly after that, a subsequent GET might not return the object due to eventual consistency.

Amazon S3 offers eventual consistency for overwrite PUTS and DELETES in all Regions.

Updates to a single key are atomic. For example, if you PUT to an existing key, a subsequent read might return
the old data or the updated data, but it never returns corrupted or partial data.

Amazon S3 achieves high availability by replicating data across multiple servers within AWS data centers. If a
PUT request is successful, your data is safely stored. However, information about the changes must replicate across 
Amazon S3, which can take some time, and so you might observe the following behaviors:
A process writes a new object to Amazon S3 and immediately lists keys within its bucket. Until the change is fully 
propagated, the object might not appear in the list.
A process replaces an existing object and immediately tries to read it. Until the change is fully propagated, Amazon
S3 might return the previous data.
A process deletes an existing object and immediately tries to read it. Until the deletion is fully propagated, 
Amazon S3 might return the deleted data.
A process deletes an existing object and immediately lists keys within its bucket. Until the deletion is fully
propagated, Amazon S3 might list the deleted object.
Note
Amazon S3 does not currently support object locking for concurrent updates. If two PUT requests are simultaneously
made to the same key, the request with the latest timestamp wins. If this is an issue, you will need to build
an object-locking mechanism into your application.

Object locking is different from the S3 Object Lock feature. With S3 Object Lock, you can store objects using a
write-once-read-many (WORM) model and prevent an object from being deleted or overwritten for a fixed amount of time
or indefinitely. For more information, see Locking objects using S3 Object Lock.

Updates are key-based. There is no way to make atomic updates across keys. For example, you cannot make the update of
one key dependent on the update of another key unless you design this functionality into your application.

Bucket configurations have a similar eventual consistency model, with the same caveats. For example, if you delete a 
bucket and immediately list all buckets, the deleted bucket might still appear in the list.

The following table describes the characteristics of an eventually consistent read and a consistent read.

Eventually consistent read	Consistent read
Stale reads possible	No stale reads
Lowest read latency	Potential higher read latency
Highest read throughput	Potential lower read throughput
Concurrent applications
This section provides examples of eventually consistent and consistent read requests when multiple clients are writing to the same items.

In this example, both W1 (write 1) and W2 (write 2) complete before the start of R1 (read 1) and R2 (read 2). For
a consistent read, R1 and R2 both return color = ruby. For an eventually consistent read, R1 and R2 might return 
color = red or color = ruby depending on the amount of time that has elapsed.


In the next example, W2 does not complete before the start of R1. Therefore, R1 might return color = ruby or
color = garnet for either a consistent read or an eventually consistent read. Also, depending on the amount of time that has
elapsed, an eventually consistent read might return no results.

