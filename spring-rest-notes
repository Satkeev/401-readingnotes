### @RequestMapping Basics
##@RequestMapping — by Path
@RequestMapping(value = "/ex/foos", method = RequestMethod.GET)
@ResponseBody
public String getFoosBySimplePath() {
    return "Get some Foos";
}
To test out this mapping with a simple curl command, run:

curl -i http://localhost:8080/spring-rest/ex/foos
##@RequestMapping — the HTTP Method
The HTTP method parameter has no default. So, if we don't specify a value, it's going to map to any HTTP request.

Here's a simple example, similar to the previous one, but this time mapped to an HTTP POST request:

##@RequestMapping(value = "/ex/foos", method = POST)
@ResponseBody
public String postFoos() {
    return "Post some Foos";
}
To test the POST via a curl command:

curl -i -X POST http://localhost:8080/spring-rest/ex/foos
3. RequestMapping and HTTP Headers
3.1. @RequestMapping With the headers Attribute
The mapping can be narrowed even further by specifying a header for the request:

##@RequestMapping(value = "/ex/foos", headers = "key=val", method = GET)
@ResponseBody
public String getFoosWithHeader() {
    return "Get some Foos with Header";
}
To test the operation, we're going to use the curl header support:
curl -i -H "key:val" http://localhost:8080/spring-rest/ex/foos
and even multiple headers via the headers attribute of @RequestMapping:
##@RequestMapping(
  value = "/ex/foos", 
  headers = { "key1=val1", "key2=val2" }, method = GET)
@ResponseBody
public String getFoosWithHeaders() {
    return "Get some Foos with Header";
}
We can test this with the command:

curl -i -H "key1:val1" -H "key2:val2" http://localhost:8080/spring-rest/ex/foos
Note that for the curl syntax, a colon separates the header key and the header value, the same as in the 
HTTP spec, while in Spring, the equals sign is used.

## @RequestMapping Consumes and Produces
Mapping media types produced by a controller method is worth special attention.

We can map a request based on its Accept header via the @RequestMapping headers attribute introduced above:

##@RequestMapping(
  value = "/ex/foos", 
  method = GET, 
  headers = "Accept=application/json")
@ResponseBody
public String getFoosAsJsonFromBrowser() {
    return "Get some Foos with Header Old";
}
The matching for this way of defining the Accept header is flexible — it uses contains instead of equals,
so a request such as the following would still map correctly:

curl -H "Accept:application/json,text/html" 
  http://localhost:8080/spring-rest/ex/foos
Starting with Spring 3.1, the @RequestMapping annotation now has the produces and consumes attributes, specifically for this purpose:

##@RequestMapping(
  value = "/ex/foos", 
  method = RequestMethod.GET, 
  produces = "application/json"
)
@ResponseBody
public String getFoosAsJsonFromREST() {
    return "Get some Foos with Header New";
}
Also, the old type of mapping with the headers attribute will automatically be converted to the new produces
mechanism starting with Spring 3.1, so the results will be identical.

This is consumed via curl in the same way:

curl -H "Accept:application/json" 
  http://localhost:8080/spring-rest/ex/foos
Additionally, produces supports multiple values as well:

##@RequestMapping(
  value = "/ex/foos", 
  method = GET,
  produces = { "application/json", "application/xml" }
)
Keep in mind that these — the old and new ways of specifying the Accept header — are basically the
same mapping, so Spring won't allow them together.

Having both these methods active would result in:

Caused by: java.lang.IllegalStateException: Ambiguous mapping found. 
Cannot map 'fooController' bean method 
java.lang.String 
org.baeldung.spring.web.controller
  .FooController.getFoosAsJsonFromREST()
to 
{ [/ex/foos],
  methods=[GET],params=[],headers=[],
  consumes=[],produces=[application/json],custom=[]
}: 
There is already 'fooController' bean method
java.lang.String 
org.baeldung.spring.web.controller
  .FooController.getFoosAsJsonFromBrowser() 
mapped.
A final note on the new produces and consumes mechanisms, which behave differently from most other annotations:
When specified at the type level, the method-level annotations do not complement but override the type-level information.

And of course, if you want to dig deeper into building a REST API with Spring, check out the new REST with Spring course.

###Spring Data Repositories
Let's start with the JpaRepository – which extends PagingAndSortingRepository and, in turn, the CrudRepository.

Each of these defines its own functionality:

###CrudRepository provides CRUD functions
PagingAndSortingRepository provides methods to do pagination and sort records
JpaRepository provides JPA related methods such as flushing the persistence context and delete records in a batch
And so, because of this inheritance relationship, the JpaRepository contains the full API of CrudRepository and PagingAndSortingRepository.

When we don't need the full functionality provided by JpaRepository and PagingAndSortingRepository, we can simply use the CrudRepository.

Let's now have a look at a quick example to understand these APIs better.

We'll start with a simple Product entity:

And let's implement a simple operation – find a Product based on its name:

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    Product findByName(String productName);
}
That's all. The Spring Data Repository will auto-generate the implementation based on the name we provided it.

This was a very simple example of course; you can go deeper into Spring Data JPA here.

###CrudRepository
Let's now have a look at the code for the CrudRepository interface:

###Downsides of Spring Data Repositories
Beyond all the very useful advantages of these repositories, there are some basic downsides of directly depending on these as well:

we couple our code to the library and to its specific abstractions, such as `Page` or `Pageable`; that's of course not unique to 
this library – but we do have to be careful not to expose these internal implementation details
by extending e.g. CrudRepository, we expose a complete set of persistence method at once. This is probably fine in most 
circumstances as well but we might run into situations where we'd like to gain more fine-grained control over the methods 
exposed, e.g. to create a ReadOnlyRepository that doesn't include the save(…) and delete(…) methods of CrudRepository

