#### Authentication and Access Control
Application security boils down to two more or less independent problems: authentication (who are you?) 
and authorization (what are you allowed to do?). Sometimes people say "access control" instead of
"authorization" which can get confusing, but it can be helpful to think of it that way because
"authorization" is overloaded in other places. Spring Security has an architecture that is designed 
to separate authentication from authorization, and has strategies and extension points for both.

An AuthenticationManager can do one of 3 things in its authenticate() method:
return an Authentication (normally with authenticated=true) if it can verify that the input represents 
a valid principal.
throw an AuthenticationException if it believes that the input represents an invalid principal.
return null if it can’t decide.
AuthenticationException is a runtime exception. It is usually handled by an application in a generic way,
depending on the style or purpose of the application. In other words user code is not normally expected to
catch and handle it. For example, a web UI will render a page that says that the authentication failed, and
a backend HTTP service will send a 401 response, with or without a WWW-Authenticate header depending on the context.

The most commonly used implementation of AuthenticationManager is ProviderManager, which delegates to a chain
of AuthenticationProvider instances. An AuthenticationProvider is a bit like an AuthenticationManager but it
has an extra method to allow the caller to query if it supports a given Authentication type:

public interface AuthenticationProvider {

	Authentication authenticate(Authentication authentication)
			throws AuthenticationException;

	boolean supports(Class<?> authentication);

}
The Class<?> argument in the supports() method is really Class<? extends Authentication> (it will only ever be asked 
if it supports something that will be passed into the authenticate() method). A ProviderManager can support multipl
e different authentication mechanisms in the same application by delegating to a chain of AuthenticationProviders. 
If a ProviderManager doesn’t recognise a particular Authentication instance type it will be skipped.

A ProviderManager has an optional parent, which it can consult if all providers return null. If the parent
is not available then a null Authentication results in an AuthenticationException.

#### Spring Auth Cheat Sheet
Step 1: set up a user model and repo
Step 2: create a controller for that model
Step 3: UserDetailsServiceImpl implements UserDetailsService
gets a User from the database by username (make sure your repository has the method to make this easy!)

Step 4: ApplicationUser implements UserDetails
use IntelliJ to implement the methods; make the boolean ones all return true

Step 5: WebSecurityConfig extends WebSecurityConfigurerAdapter
has a UserDetailsService
passwordEncoder bean
configure AuthManagerBuilder
auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
configure HttpSecurity
cors? csrf?
matchers for URLs that are allowed
ensure that login and signup URLs allowed; also consider homepage etc.
formLogin with login page set up
logout
    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
Step 6: registration page
create it w/ form
ensure it posts to a route your controller is ready for
check it's saving in the DB
    // maybe autologin?
    Authentication authentication = new UsernamePasswordAuthenticationToken(newUser, null, new ArrayList<>());
    SecurityContextHolder.getContext().setAuthentication(authentication);
Step 7: login page
create it w/ form
ensure it posts to the route you specified in web config
try it out!
add to a template w/ things about the Principal
